# Repairability

This module takes a list of revision as input and outputs produces a list of instances/diffs that could have been generated by one of the supported repair-tools. 

The flow of this module is as follows:

- Apply FineGrainDifftAnalyzer to input: This basically produces a list of fine-grained diffs/revisions in the input
- Use `fr.inria.coming.repairability.RepairTools` to get list of patterns to be mined as per repair-tools specified in `-repairtool`
- We use patterns we get from above and invoke `PatternInstanceAnalyzer`, 
which outputs a list of instances that match any one of the patterns given as input.
- The output of `PatternInstanceAnalyzer` is given `RepairabilityAnalyzer. It invokes filter(of the repair-tool, with whose pattern it was matched) on each instance found above
- The output of `RepairabilityAnalyzer` is given to  `JSONRepairabilityOutput`, which produces a json with a list of instances
    - each instance is a single revision
    - each revision has a list of repairability
    - each repairability represents a single repair tool that could have generated that revision
 
 
## How to add a new Repair Tool

- Create a new class, `x`, in the package `fr.inria.coming.repairability.repiartools`. `x` should extend `fr.inria.coming.repairability.repiartools.AbstractRepairTool`.
- Add the name of the class, `x`, to the array `supportedTools` in `fr.inria.coming.repairability.RepairTools`
- The new class should at least implement the method ` protected List<ChangePatternSpecification> readPatterns()`
- The class may override ` public boolean filter(ChangePatternInstance instance, IRevision revision);`

### readPatterns()

Each repair tool has a particular search space, i.e, the patches produced by it are supposed to have a certain kind of characteristics.
We believe that this search space can be specified by [Change Pattern Specification(or patterns)](https://github.com/SpoonLabs/coming#change-pattern-specification).
For example, if a commit only changes a binary operator, it is in the search space of jMutRepair and it can be represented by the following pattern:
```xml
<pattern name="binary">
	<entity id="1" type="BinaryOperator"/>
	<action entityId="1" type="UPD"/>
</pattern>
```
This xml pattern is abstracted as `ChangePatternSpecification` in Coming. 
This method is supposed to return all the patterns(that helps in specifying the search space of that tool) in form a list of ChangePatternSpecification.
One of the methods to do it is:
- add the required .xml files to a folder `/src/main/resources/repairability/<repair-tool-name>/`
- read those .xml file using `PatternXMLParser.parseFile(getPathFromResources(fileName))`, which returns a single ChangePatternSpecification corresponding to the xml.
- read all all the .xml for that repair tool and return a `List<ChangePatternSpecification>`.
 

The output of `readPatterns()` will be modified a little bit by `AbstractRepairTool.getPatterns()` and then given to `PatternInstanceAnalyser` to mine the required patterns.

### filter()
Certain characteristics/features of search space of a repair-tool can't be specified in the .xml or the Change Pattern Specification. 
There filter function is provided to specify extra constrains over the instances mined `PatternInstanceAnalyzer` 
using the patterns provided by `readPatterns()` of that repair-tool.
This means that we can allow patterns in readPatterns() to be lenient and apply stronger checks in filter to get the desired search space.
 `ChangePatternInstance` is a very information rich object that contains almost all the information about the AST nodes involved.

A `ChangePatternInstance` object is input to the `filter()`. The object represents a change instance in code that was matched with one of the patterns specific to that repair-tool.
If `filter()` returns false, the `ChangePatternInstance` is dropped. Otherwise it is passed to the output processor.  

We also pass the `IRevision` corresponding to the instance in the filter function. This can be used get the source code involving the revision
and therefore it can prove helpful in cases like JGenProg, where we want to check if the inserted/updated statement was present in the previous version of the file.
  
## Usage
Though you need to implement `readPatterns()`, one should only use `getPatterns()` while trying to use the repair tool module.
`RepairTools` class provides several features to use one or several repair-tools with ease.
 
## analyse function of repairability notes:

-  **One file modification per commit/IRevision**
    Each input(aka commit or IRevision) should have modification in only one file. 
    If a revision modifies more than one file then, it couldnt have be generated by a repair-tool.

- **<= 1 instance of each repair tool per commit/IRevision**
    Each commit(aka IRevision) should have not more than one instances of a particular repair tool.
    This is because the repair tools we are dealing make patches which affects just one file and each patch corresponds to a revision or commit.
   
    More discussion about the same can be found here: https://github.com/SpoonLabs/coming/issues/94
    one instancePerDiff represent one result/one revision and in one revision there should be at max of one instance of any repair-tool
